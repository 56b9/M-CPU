
        //two byte instructions
        //Loading
        case 32: //LD ACC
            *AP = FETCH;
            break;
        case 33: //LD X
            X = FETCH;
            break;
        case 34: //LD Y
            Y = FETCH;
            break;
        case 35: //LD Z
            Z = FETCH;
            break;
        case 36: //LD F
            F = FETCH;
            break;
        
        //Interrupts (software and hardware)
        /*Vectors:
        * 0: 0x08
        * 1: 0x10
        * 2: 0x18
        * 3: 0x20
        * 4: 0x28
        * 5: 0x30
        * 6: 0x38
        * 7: 0x40
        */
        case 37: //INT A
            if (testBit(F, 7) == 0) {
                jump(vector[0]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) { //mask bit accept 
                    return;
                }
                else {
                    jump(vector[0]);
                }
            }
            break;
        
        case 38: //INT B
            if (testBit(F, 7) == 0) {
                jump(vector[1]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[1]);
                }
            }
            break;
        
        case 39: //INT C
            if (testBit(F, 7) == 0) {
                jump(vector[2]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[2]);
                }
            }
            break;
        
        case 40: //INT D
            if (testBit(F, 7) == 0) {
                jump(vector[3]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[3]);
                }
            }
            break;
        
        case 41: //INT E
            if (testBit(F, 7) == 0) {
                jump(vector[4]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[4]);
                }
            }
            break;
        
        case 42: //INT F
            if (testBit(F, 7) == 0) {
                jump(vector[5]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[5]);
                }
            }
            break;
        
        case 43: //INT G
            if (testBit(F, 7) == 0) {
                jump(vector[6]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[6]);
                }
            }
            break;
        
        case 44: //INT H
            if (testBit(F, 7) == 0) {
                jump(vector[7]);
            } 
            else if (testBit(F, 7) != 0) {
                if (FETCH >= 1) {
                    return;
                }
                else {
                    jump(vector[7]);
                }
            }
            break;
        
        //TRAPs 
        case 45: //TRP A
            jump(trap[0]);
            break;
        case 46: //TRP B
            jump(trap[1]);
            break;
        case 47: //TRP C
            jump(trap[2]);
            break;
        case 48: //TRP D
            jump(trap[3]);
            break;
        //end interrupts------------
        
        
        
        
        
        
        
        
        //three byte instructions--------------
        //W/RMOV
        case 64: //WMOV ACC 
            writeData(AH, *AP); //write to RAM
            break;
        case 65: //RMOV ACC
            readData(AH, &*AP); //read from RAM
            break;
        case 66: //WMOV X
            writeData(AH, X);
            break;
        case 67: //RMOV X
            readData(AH, &X);
            break;
        case 68: //WMOV Y
            writeData(AH, Y);
            break;
        case 69: //RMOV Y
            readData(AH, &Y);
            break;
        case 70: //WMOV Z
            writeData(AH, Z);
            break;
        case 71: //RMOV Z
            readData(AH, &Z);
            break;
        case 72: //WMOV F
            writeData(AH, Z);
            break;
        case 73: //RMOV F
            readData(AH, &F);
            break;
        case 74: //WMOV SP LOW (moves lowest byte of SP into memory)
            writeData(AH, SP&0xff);
            break;
        case 75: //WMOV SP HIGH (moves highest byte of SP into memory)
            writeData(AH, (SP >> 8)&0xff);
            break;
        case 76: //WMOV IX LOW
            writeData(AH, IX&0xff);
            break;
        case 77: //WMOV IX HIGH 
            writeData(AH, (IX >> 8)&0xff);
            break;
        //End W/RMOV
        
        //Conditional Branching (Bits 4 and 7 are not used for branching)
        case 80: //JMP
            jump(AH);
            break;
        case 81: //JMP P
            if (testBit(F, 0) != 0) {jump(AH);} //parity
            else {return;}
            break;
        case 82: //JMP O
            if (testBit(F, 1) != 0) {jump(AH);} //Overflow
            else {return;}
            break;
        case 83: //JMP U
            if (testBit(F, 2) != 0) {jump(AH);} //Underflow
            else {return;}
            break;
        case 84: //JMP Z
            if (testBit(F, 3) != 0) {jump(AH);} //Zero
            else {return;}
            break;
        case 85: //JMP UD1
            if (testBit(F, 5) != 0) {jump(AH);} //User-defined
            else {return;}
            break;
        case 86: //JMP UD2
            if (testBit(F, 6) != 0) {jump(AH);} //User-defined
            else {return;}
            break;
        //inverse conditional branching
        case 87: //JMP NP
            if (testBitZero(F, 1) == 0) {jump(AH);} //parity
            else {return;}
            break;
        case 88: //JMP NO
            if (testBitZero(F, 2) == 0) {jump(AH);} //Overflow
            else {return;}
            break;
        case 89: //JMP NU
            if (testBitZero(F, 4) == 0) {jump(AH);} //Underflow
            else {return;}
            break;
        case 90: //JMP NZ
            if (testBitZero(F, 8) == 0) {jump(AH);} //Zero
            else {return;}
            break;
        case 91: //JMP NUD1
            if (testBitZero(F, 32) == 0) {jump(AH);} //User-defined
            else {return;}
            break;
        case 92: //JMP NUD2
            if (testBitZero(F, 64) == 0) {jump(AH);} //User-defined
            else {return;}
            break;
        //End conditional branching
        
        //16 bit loads
        case 93: //LD IX 
            IX = AH;
            break;
        case 94: //LD FX
            F = (AH >> 8)&0xff; //high
            X = AH&0xff; //low
            break;
        case 95: //LD YZ
            Y = (AH >> 8)&0xff;
            Z = AH&0xff;
            break;
        //end 16 bit loads
        case 127: //SETSTK
            SP = AH;
            spCheck();
            break;
        //end three byte instructions--------
        
       







        
        
        
        //one byte instructions
        case 0: //NOP
            return;
            break;
        case 1: //MOV ACCX (src, dest)
            X = *AP;
            break;
        case 2: //MOV ACCY 
            Y = *AP;
            break;
        case 3: //MOV ACCZ
            Z = *AP;
            break;
        case 4: //MOV ACCF
            F = *AP;
            break;
        case 5: //ACC X
            *AP = X;
            break;
        case 6: //MOV XY
            Y = X;
            break;
        case 7: //MOV XZ
            Z = X;
            break;
        case 8: //ACC Y
            *AP = Y;
            break;
        case 9: //MOV YX
            X = Y;
            break;
        case 10: //MOV YZ
            Z = Y;
            break;
        case 11: //ACC Z
            *AP = Z;
            break;
        case 12: //MOV ZX
            X = Z;
            break;
        case 13: //MOV ZY
            Y = Z;
            break;
        case 14: //ACC F
            *AP = F;
            break;
        case 15: //UNUSED/NOP
            return;
            break;
        case 16: //HLD X
            *BP = X;
            break;
        case 17: //HLD Y
            *BP = Y;
            break;
        case 18: //HLD Z
            *BP = Z;
            break;
        //ALU Operations
        case 19: //ADD
            *AP = ALU(*AP, *BP, ADD);
            break;
        case 20: //SUB
            *AP = ALU(*AP, *BP, SUB);
            break;
        case 21: //AND
            *AP = ALU(*AP, *BP, AND);
            break;
        case 22: //OR
            *AP = ALU(*AP, *BP, OR);
            break;
        case 23: //XOR
            *AP = ALU(*AP, *BP, XOR);
            break;
        case 24: //NOT
            *AP = ALU(*AP, *BP, NOT);
            break;
        
        //Accumulator Switching
        case 25: //SET A
            assignAccumulator(1);
            break;
        case 26: //SET AB
            assignAccumulator(2);
            break;
        
        //HLD 
        case 27: //ACC HLD
            *AP = *BP;
            break;
        case 28: //MOV HLD X
            X = *BP;
            break;
        case 29: //MOV HLD Y
            Y = *BP;
            break;
        case 30: //MOV HLD Z
            Z = *BP;
            break;
        //END HLD
            
        case 31: //HLT
            halt();
            break;
         
       //One Byte Instructions-------- 
        case 128: //NOP
            return;
            break;
        case 129: //JMP IX
            jump(IX);
            break;
        case 130: //JMP OFF (offset jump
            jump(PC+IX);
            break;
        
        //Other MOVs
        case 134: //MOV IX PC
            PC = IX - 1;
            break;
        case 135: //MOV PC IX
            IX = PC;
            break;
        case 136: //MOV IX SP
            SP = IX;
            break;
        case 137: //MOV SP IX
            IX = SP;
            break;
        //End Other MOVs
        
        //Stack--------------
        case 138: //PUSH ACC
            SP--;
            temp = spCheck();
            if (temp == 1) {
                break;
            }
            memory[SP] = *AP;
            break;
        case 139: //POP ACC
            *AP = memory[SP];
            SP++;
            break;
        case 140: //PUSH X
            SP--;
            temp = spCheck();
            if (temp == 1) {
                break;
            }
            memory[SP] = X;
            break;
        case 141: //POP X
            X = memory[SP];
            SP++;
            break;
        case 142: //PUSH Y
            SP--;
            temp = spCheck();
            if (temp == 1) {
                break;
            }
            memory[SP] = Y;
            break;
        case 143: //POP Y
            Y = memory[SP];
            SP++;
            break;
        case 144: //PUSH Z
            SP--;
            temp = spCheck();
            if (temp == 1) {
                break;
            }
            memory[SP] = Z;
            break;
        case 145: //POP Z
            Z = memory[SP];
            SP++;
            break;
        //END STACK--------       
        
        //16 bit MOV
        case 152: //MOV FX IX
            IX = combine(F, X);
            break;
        case 153: //MOV YZ IX
            IX = combine(Y, Z);
            break;
        case 154: //MOV FX SP
            SP = combine(F, X);
            break;
        case 155: //MOV YZ SP
            SP = combine(Y, Z);
            break;
        case 156: //MOV FX PC
            PC = combine(F, X);
            break;
        case 157: //MOV YZ PC
            PC = combine(Y, Z);
            break;
        case 158: //MOV IX FX
            F = (IX >> 8)&0xff; //high 
            X = IX&0xff; //low
            break;
        case 159: //MOV IX YZ
            Y = (IX >> 8)&0xff;
            Z = IX&0xff;
            break;
        case 160: //MOV SP FX
            F = (SP >> 8)&0xff;
            X = SP&0xff;
            break;
        case 161: //MOV SP YZ
            Y = (SP >> 8)&0xff;
            Z = SP&0xff;
            break;
        case 162: //MOV PC FX
            F = (PC >> 8)&0xff;
            X = PC&0xff;
            break;
        case 163: //MOV PC YZ
            Y = (PC >> 8)&0xff;
            Z = PC&0xff;
            break;
        //END 16 bit MOV
        
        //INC
        case 164: //INC ACC
            (*AP)++;
            break;
        case 165: //INC HLD
            (*BP)++;
            break;
        case 166: //INC X
            X++;
            break;
        case 167: //INC Y
            Y++;
            break;
        case 168: //INC Z
            Z++;
            break;
        case 169: //INC IX
            IX++;
            break;
        //END INC
        
        //DEC
        case 170: //DEC ACC
            (*AP)--;
            break;
        case 171: //DEC HLD
            (*BP)--;
            break;
        case 172: //DEC X
            X--;
            break;
        case 173: //DEC Y
            Y--;
            break;
        case 174: //DEC Z
            Z--;
            break;
        case 175: //DEC IX
            IX--;
            break;
        //END DEC
        
        //Indexed read/write
        case 176: //IX WMOV ACC
            writeData(IX, *AP); //write to RAM
            break;
        case 177: //IX RMOV ACC
            readData(IX, &*AP); //read from RAM
            break;
        case 178: //IX WMOV X
            writeData(IX, X); 
            break;
        case 179: //IX RMOV X
            readData(IX, &X); 
            break;
        case 180: //IX WMOV Y
            writeData(IX, Y); 
            break;
        case 181: //IX RMOV Y
            readData(IX, &Y); 
            break;
        case 182: //IX WMOV Z
            writeData(IX, Z); 
            break;
        case 183: //IX RMOV Z
            readData(IX, &Z); 
            break;
        case 184: //IX WMOV F
            writeData(IX, F); 
            break;
        case 185: //IX RMOV F
            readData(IX, &F); 
            break;
        //end Indexed read/write
        
        //Indexed Branching-----
        case 196: //IX JMP P
            if (testBit(F, 0) != 0) {jump(IX);}
            else {return;}
            break;
        case 197: //IX JMP O
            if (testBit(F, 1) != 0) {jump(IX);}
            else {return;}
            break;
        case 198: //IX JMP U
            if (testBit(F, 2) != 0) {jump(IX);}
            else {return;}
            break;
        case 199: //IX JMP Z
            if (testBit(F, 3) != 0) {jump(IX);}
            else {return;}
            break;
        case 200: //IX JMP UD1
            if (testBit(F, 5) != 0) {jump(IX);}
            else {return;}
            break;
        case 201: //IX JMP UD2
            if (testBit(F, 6) != 0) {jump(IX);}
            else {return;}
            break;
        //inverse conditional branching
        case 202: //JMP NP
            if (testBitZero(F, 1) == 0) {jump(IX);} //parity
            else {return;}
            break;
        case 203: //JMP NO
            if (testBitZero(F, 2) == 0) {jump(IX);} //Overflow
            else {return;}
            break;
        case 204: //JMP NU
            if (testBitZero(F, 4) == 0) {jump(IX);} //Underflow
            else {return;}
            break;
        case 205: //JMP NZ
            if (testBitZero(F, 8) == 0) {jump(IX);} //Zero
            else {return;}
            break;
        case 206: //JMP NUD1
            if (testBitZero(F, 32) == 0) {jump(IX);} //User-defined
            else {return;}
            break;
        case 207: //JMP NUD2
            if (testBitZero(F, 64) == 0) {jump(IX);} //User-defined
            else {return;}
            break;
        
        //END IX BRANCHING
        case 255: //CLF
            F = 0;
            break;